substitutions:
  name: daly-bms
  device_description: "Monitor and control a Daly BMS via UART"

esphome:
  name: ${name}
  comment: ${device_description}

esp32:
  board: nodemcu-32s
  framework:
    type: esp-idf

# Enable logging
logger:

# Enable Home Assistant API
api:
  encryption:
    key: "aAY0fYv5Avc9gqClXa4mY8OGxyTouxCPXxOO8QNFj8U="

ota:
  password: "L1ttl3greenm3n"

wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password
  output_power: 8.5db
  power_save_mode: HIGH

  # Enable fallback hotspot (captive portal) in case wifi connection fails
  ap:
    ssid: "daly-bms"
    password: !secret ap_pw

captive_portal:

uart:
  tx_pin: GPIO1
  rx_pin: GPIO3
  baud_rate: 9600
  rx_buffer_size: 512

daly_bms:
  update_interval: 20s

sensor:
  - platform: wifi_signal
    name: "WiFi Signal Daly BMS"
    update_interval: 30s
  - platform: daly_bms
    voltage:
      name: "${name} Battery Voltage"
    current:
      name: "${name} Battery Current"
    battery_level:
      name: "${name} Battery Level"
    max_cell_voltage:
      name: "${name} Max Cell Voltage"
    max_cell_voltage_number:
      name: "${name} Max Cell Voltage Number"
    min_cell_voltage:
      name: "${name} Min Cell Voltage"
    min_cell_voltage_number:
      name: "${name} Min Cell Voltage Number"
    remaining_capacity:
      name: "${name} Remaining Capacity"
    cells_number:
      name: "${name} Cells Number"
    temperature_1:
      name: "${name} Temperature 1"
    temperature_2:
      name: "${name} Temperature 2"
    cell_1_voltage:
      name: "${name} Cell 1 Voltage"
    cell_2_voltage:
      name: "${name} Cell 2 Voltage"
    cell_3_voltage:
      name: "${name} Cell 3 Voltage"
    cell_4_voltage:
      name: "${name} Cell 4 Voltage"
    cell_5_voltage:
      name: "${name} Cell 5 Voltage"
    cell_6_voltage:
      name: "${name} Cell 6 Voltage"
    cell_7_voltage:
      name: "${name} Cell 7 Voltage"      

text_sensor:
  - platform: daly_bms
    status:
      name: "${name} Status"

binary_sensor:
  - platform: daly_bms
    charging_mos_enabled:
      name: "${name} Charging MOS"
      id: bin_daly_chg_mos # binary MOS sensor must have ID to use with switch
      internal: True # but you can make it internal to avoid duplication
    discharging_mos_enabled:
      name: ${name} Discharging MOS"
      id: bin_daly_dischg_mos # binary MOS sensor must have ID to use with switch
      internal: True # but you can make it internal to avoid duplication


switch:
  - platform: template
    name: "${name} Charging MOS"
    restore_mode: RESTORE_DEFAULT_OFF
    lambda: |-
      if (id(bin_daly_chg_mos).state) {
        return true;
      } else {
        return false;
      }
    turn_on_action:
      - uart.write:
          data: [0xA5, 0x40, 0xDA, 0x08, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC8]
      - logger.log:
          format: "Send cmd to Daly: Set charge MOS on"
    turn_off_action:
      - uart.write:
          data: [0xA5, 0x40, 0xDA, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC7]
      - logger.log:
          format: "Send cmd to Daly: Set charge MOS off"

  - platform: template
    name: "${name}  Discharging MOS"
    restore_mode: RESTORE_DEFAULT_OFF    
    lambda: |-
      if (id(bin_daly_dischg_mos).state) {
        return true;
      } else {
        return false;
      }
    turn_on_action:
      - uart.write:
          data: [0xA5, 0x40, 0xD9, 0x08, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC7]
      - logger.log:
          format: "Send cmd to Daly: Set discharge MOS on"
    turn_off_action:
      - uart.write:
          data: [0xA5, 0x40, 0xD9, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC6]
      - logger.log:
          format: "Send cmd to Daly: Set discharge MOS off"
